<html>
  <head>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <nav class="navbar">

    </nav>

    <main>
      <h1>Android Database: ROOM </h1>
      <p>Room has been out for serveral years, I haven't used it until this year. And I do learn a lot this time, and would like to take a note of it.  Before I dive in, I would say, the version of Room I'm using is :</p>
      <pre>
        def room_version = "2.2.2"

        // ROOM
        implementation "androidx.room:room-runtime:$room_version"
        kapt "androidx.room:room-compiler:$room_version"
        implementation "androidx.room:room-ktx:$room_version" // ktx + Coroutine
        By the way, you can check here to see the release log of Room.
      </pre>

      <h2>Relation</h2>
      <p>multiple tables and there might be 1:1, 1:Many, Many:Many relation among these tables.      I would like to explain how to build a many to many relation using Room, as this is the hardest relation for us. Say I have a recipe database, which has two tables: "ingredient" and "recipe". The relation between ingredient and recipe, of course, are many to many. Here is how we retrieve data from Database</p>
      <pre>
        @Entity
        data class Ingredient(
            val name: String,
            val isVegi: Int,
            @PrimaryKey(autoGenerate = true) var ingredientId: Int = 0
        )

        @Entity
        data class Cuisine(
            val name: String,
            @PrimaryKey(autoGenerate = true) var cuisineId: Int = 0
        )
      </pre>

      <h2>pre-packaged database</h2>
      <p>We didnt' have a pre-packaged database before ROOM 2.2. What we did is to insert a bunch of tables on the fresh install, but also need to be careful that we don't create tables every time we open the app.Lucky for us, ROOM 2.2 support pre-packaged database now. We can now put the database files to assert or file system. And since we need to place our pre-defined database to our apk, we normally would like to put it to assert foldwer.</p>
      <pre>
        database = Room.databaseBuilder(
            context.applicationContext,
            RecipeDatabase::class.java,
            "recipes.db"
        )
        .createFromAsset("database/recipe.app")
        .build()
      </pre>

      <h1>search text</h1>
      <p>We would type Select name from cuisine where name like '%egg%' to search data by a substring in a SQLite console. That's right. But things get a litte different in the ROOM. ROOM does not support the %% yet. So you have to do a text search by this</p>
      <pre>
        // DAO
        @Query("select * from Cuisine where name like :keyword")
            suspend fun getCuisinesBy(keyword: String): List&lt;Cuisine&gt;

        // ViewModel
        val arg = "%$keyword%"
        val cuisines = dao.getCuisinesBy(arg)
      </pre>


      <h2>unit test</h2>
      <p>One most important rule of unit test is "you can only fail one test because your logic is not working as you expected". That means, the connectivity of network/database, the multi-thread random issues should not be the reason to fail your test. The solution for that is isolation. Same for unit test against database code. We have to have a mock database to test, so tests don't fail just because the database connectivity.The wait to finish is another issue we have to deal with in the unit test. In the production, it's okay to wait the code to get the data from back-end or database. It's understandable. But when it comes to unit test, we need the unit test to run as fast as possible. (another import rule of unit test: fast!!!)</p>
      <pre>
            @Test
            fun insertManyToManyRelation_queryingGetsResults() = runBlocking {
                dao.insertCuisine(Cuisine("pizza", 1))
                dao.insertIngredient(Ingredient("dough", 3, 1, ""))
                dao.insertIngredient(Ingredient("chicken", 2, 0, ""))
                dao.insertJoint(IngredientCuisine(1, 1))
                dao.insertJoint(IngredientCuisine(2, 1))

                val result = dao.cuisinesWithIngredients()
                assertEquals(1, result.size)
                assertEquals(2, result[0].ingredients.size)
            }
      </pre>
    </main>
  </body>
</html>
